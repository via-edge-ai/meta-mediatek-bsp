From fb7a93e5cc94b1e5a0d31109da648caf95e3ca05 Mon Sep 17 00:00:00 2001
From: DavidBHHsu <DavidBHHsu@via.com.tw>
Date: Tue, 16 Jul 2024 15:58:01 +0800
Subject: [PATCH] Add the driver for ov5648 camera.

---
 Makefile                                      |    2 +-
 .../misc/mediatek/imgsensor/src-v4l2/Makefile |    3 +
 .../ov5648_mipi_raw/ov5648mipiraw_Sensor.c    | 1906 +++++++++++++++++
 .../ov5648_mipi_raw/ov5648mipiraw_Sensor.h    |  164 ++
 .../src-v4l2/common/ov5648_mipi_raw/subdrv.mk |    9 +
 5 files changed, 2083 insertions(+), 1 deletion(-)
 create mode 100644 drivers/misc/mediatek/imgsensor/src-v4l2/common/ov5648_mipi_raw/ov5648mipiraw_Sensor.c
 create mode 100644 drivers/misc/mediatek/imgsensor/src-v4l2/common/ov5648_mipi_raw/ov5648mipiraw_Sensor.h
 create mode 100644 drivers/misc/mediatek/imgsensor/src-v4l2/common/ov5648_mipi_raw/subdrv.mk

diff --git a/Makefile b/Makefile
index 8f4c7e1..c2b7159 100644
--- a/Makefile
+++ b/Makefile
@@ -21,7 +21,7 @@ export CONFIG_VIDEO_MTK_ISP_7_IMGSYS=m
 export CONFIG_VIDEO_MTK_ISP_7_CAMSYS_UT=n
 export CONFIG_VIDEO_MEDIATEK_CAMERA=m
 export CONFIG_MTK_V4L2_IMGSENSOR=m
-export CONFIG_CUSTOM_KERNEL_IMGSENSOR="imx214_mipi_raw imx214d2l_mipi_raw ar0430ap1302_mipi_yuv ar0830ap1302_mipi_yuv ar0830ap1302d2l_mipi_yuv"
+export CONFIG_CUSTOM_KERNEL_IMGSENSOR="ov5648_mipi_raw"
 
 export top := $(src)
 
diff --git a/drivers/misc/mediatek/imgsensor/src-v4l2/Makefile b/drivers/misc/mediatek/imgsensor/src-v4l2/Makefile
index c88a1f4..adb5f6b 100644
--- a/drivers/misc/mediatek/imgsensor/src-v4l2/Makefile
+++ b/drivers/misc/mediatek/imgsensor/src-v4l2/Makefile
@@ -38,6 +38,9 @@ subdir-ccflags-y += \
 	-I$(MTK_ISP_DRIVER_PATH)/ \
 	-I$(MTK_CAMSYS_DRIVER_PATH)/ \
 
+subdir-ccflags-y += -DDEBUG
+ccflags-y += -DDEBUG
+
 imgsensor-objs := \
 	adaptor-hw.o \
 	adaptor-drv.o \
diff --git a/drivers/misc/mediatek/imgsensor/src-v4l2/common/ov5648_mipi_raw/ov5648mipiraw_Sensor.c b/drivers/misc/mediatek/imgsensor/src-v4l2/common/ov5648_mipi_raw/ov5648mipiraw_Sensor.c
new file mode 100644
index 0000000..2951a96
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src-v4l2/common/ov5648_mipi_raw/ov5648mipiraw_Sensor.c
@@ -0,0 +1,1906 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (c) 2019 MediaTek Inc.
+#include <linux/videodev2.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/cdev.h>
+#include <linux/uaccess.h>
+#include <linux/fs.h>
+#include <linux/atomic.h>
+#include <linux/types.h>
+
+#include "kd_camera_typedef.h"
+#include "kd_imgsensor.h"
+#include "kd_imgsensor_define_v4l2.h"
+#include "kd_imgsensor_errcode.h"
+
+#include "ov5648mipiraw_Sensor.h"
+
+#include "adaptor-subdrv.h"
+#include "adaptor-i2c.h"
+
+#define read_cmos_sensor_8(...) subdrv_i2c_rd_u8(__VA_ARGS__)
+#define write_cmos_sensor_8(...) subdrv_i2c_wr_u8(__VA_ARGS__)
+
+#define PFX "OV5648_camera_sensor"
+#define LOG_ERR(format, args...)\
+	pr_err(PFX "[%s] " format, __func__, ##args)
+#define LOG_WARN(format, args...)\
+	pr_warn(PFX "[%s] " format, __func__, ##args)
+#define LOG_INFO(format, args...)\
+	pr_info(PFX "[%s] " format, __func__, ##args)
+#define LOG_DBG(format, args...)\
+	pr_debug(PFX "[%s] " format, __func__, ##args)
+#define LOG_INF LOG_INFO
+
+#define OV5648_SUPPORTED_SENSOR_MODE_NUMBER 5
+
+#define LOCAL_BASEGAIN 1024
+#define MAX_GAIN (LOCAL_BASEGAIN * 64)
+#define MIN_GAIN (LOCAL_BASEGAIN * 1)
+#define GAIN_STEP 1
+
+static struct imgsensor_info_struct imgsensor_info = {
+	.sensor_id = OV5648MIPI_SENSOR_ID,
+	.checksum_value = 0xf61b7b7c,
+
+	.pre = {
+		.pclk = 84000000,  //record different mode's pclk
+		.linelength = 2500,  //record different mode's linelength
+		.framelength = 1120,  //record different mode's framelength
+		.startx = 0,  //record different mode's startx of grabwindow
+		.starty = 0,  //record different mode's starty of grabwindow
+		//record different mode's width of grabwindow
+		.grabwindow_width = 1920,
+		//record different mode's height of grabwindow
+		.grabwindow_height = 1080,
+		/* following for
+		 * MIPIDataLowPwr2HighSpeedSettleDelayCount
+		 * by different scenario
+		 */
+		.mipi_data_lp2hs_settle_dc = 85,
+		.mipi_pixel_rate = 84000000,
+		// following for GetDefaultFramerateByScenario()
+		.max_framerate = 300,
+	},
+	.cap = {
+		.pclk = 84000000,  //record different mode's pclk
+		.linelength = 2500,  //record different mode's linelength
+		.framelength = 1120,  //record different mode's framelength
+		.startx = 0,  //record different mode's startx of grabwindow
+		.starty = 0,  //record different mode's starty of grabwindow
+		//record different mode's width of grabwindow
+		.grabwindow_width = 1920,
+		//record different mode's height of grabwindow
+		.grabwindow_height = 1080,
+		/* following for
+		 * MIPIDataLowPwr2HighSpeedSettleDelayCount
+		 * by different scenario
+		 */
+		.mipi_data_lp2hs_settle_dc = 85,
+		.mipi_pixel_rate = 84000000,
+		// following for GetDefaultFramerateByScenario()
+		.max_framerate = 300,
+	},
+	.cap1 = {
+		.pclk = 84000000,  //record different mode's pclk
+		.linelength = 2500,  //record different mode's linelength
+		.framelength = 1120,  //record different mode's framelength
+		.startx = 0,  //record different mode's startx of grabwindow
+		.starty = 0,  //record different mode's starty of grabwindow
+		//record different mode's width of grabwindow
+		.grabwindow_width = 1920,
+		//record different mode's height of grabwindow
+		.grabwindow_height = 1080,
+		/* following for
+		 * MIPIDataLowPwr2HighSpeedSettleDelayCount
+		 * by different scenario
+		 */
+		.mipi_data_lp2hs_settle_dc = 85,
+		.mipi_pixel_rate = 84000000,
+		// following for GetDefaultFramerateByScenario()
+		.max_framerate = 300,
+	},
+	.cap2 = {
+		.pclk = 84000000,  //record different mode's pclk
+		.linelength = 2500,  //record different mode's linelength
+		.framelength = 1120,  //record different mode's framelength
+		.startx = 0,  //record different mode's startx of grabwindow
+		.starty = 0,  //record different mode's starty of grabwindow
+		//record different mode's width of grabwindow
+		.grabwindow_width = 1920,
+		//record different mode's height of grabwindow
+		.grabwindow_height = 1080,
+		/* following for
+		 * MIPIDataLowPwr2HighSpeedSettleDelayCount
+		 * by different scenario
+		 */
+		.mipi_data_lp2hs_settle_dc = 85,
+		.mipi_pixel_rate = 84000000,
+		// following for GetDefaultFramerateByScenario()
+		.max_framerate = 300,
+	},
+	.normal_video = {
+		.pclk = 84000000,  //record different mode's pclk
+		.linelength = 2500,  //record different mode's linelength
+		.framelength = 1120,  //record different mode's framelength
+		.startx = 0,  //record different mode's startx of grabwindow
+		.starty = 0,  //record different mode's starty of grabwindow
+		//record different mode's width of grabwindow
+		.grabwindow_width = 1920,
+		//record different mode's height of grabwindow
+		.grabwindow_height = 1080,
+		/* following for
+		 * MIPIDataLowPwr2HighSpeedSettleDelayCount
+		 * by different scenario
+		 */
+		.mipi_data_lp2hs_settle_dc = 85,
+		.mipi_pixel_rate = 84000000,
+		// following for GetDefaultFramerateByScenario()
+		.max_framerate = 300,
+	},
+	.hs_video = {
+		.pclk = 84000000,  //record different mode's pclk
+		.linelength = 2500,  //record different mode's linelength
+		.framelength = 1120,  //record different mode's framelength
+		.startx = 0,  //record different mode's startx of grabwindow
+		.starty = 0,  //record different mode's starty of grabwindow
+		//record different mode's width of grabwindow
+		.grabwindow_width = 1920,
+		//record different mode's height of grabwindow
+		.grabwindow_height = 1080,
+		/* following for
+		 * MIPIDataLowPwr2HighSpeedSettleDelayCount
+		 * by different scenario
+		 */
+		.mipi_data_lp2hs_settle_dc = 85,
+		.mipi_pixel_rate = 84000000,
+		// following for GetDefaultFramerateByScenario()
+		.max_framerate = 300,
+	},
+	.slim_video = {
+		.pclk = 84000000,  //record different mode's pclk
+		.linelength = 2500,  //record different mode's linelength
+		.framelength = 1120,  //record different mode's framelength
+		.startx = 0,  //record different mode's startx of grabwindow
+		.starty = 0,  //record different mode's starty of grabwindow
+		//record different mode's width of grabwindow
+		.grabwindow_width = 1920,
+		//record different mode's height of grabwindow
+		.grabwindow_height = 1080,
+		/* following for
+		 * MIPIDataLowPwr2HighSpeedSettleDelayCount
+		 * by different scenario
+		 */
+		.mipi_data_lp2hs_settle_dc = 85,
+		.mipi_pixel_rate = 84000000,
+		// following for GetDefaultFramerateByScenario()
+		.max_framerate = 300,
+	},
+	.margin = 10,
+	.min_shutter = 1,
+	.min_gain = MIN_GAIN,
+	.max_gain = MAX_GAIN,
+	.min_gain_iso = 100,
+	.exp_step = 2,
+	.gain_step = GAIN_STEP,
+	.gain_type = 0,
+	.max_frame_length = 0xffff,
+	.ae_shut_delay_frame = 0,
+	.ae_sensor_gain_delay_frame = 1,
+	.ae_ispGain_delay_frame = 2,
+	.ihdr_support = 0,    //1, support; 0,not support
+	.ihdr_le_firstline = 0,  //1,le first ; 0, se first
+	.sensor_mode_num = OV5648_SUPPORTED_SENSOR_MODE_NUMBER,    //support sensor mode num
+
+	.cap_delay_frame = 3,
+	.pre_delay_frame = 3,
+	.video_delay_frame = 3,
+	.hs_video_delay_frame = 3,
+	.slim_video_delay_frame = 3,
+
+	.isp_driving_current = ISP_DRIVING_2MA,
+	.sensor_interface_type = SENSOR_INTERFACE_TYPE_MIPI,
+	//0,MIPI_OPHY_NCSI2;  1,MIPI_OPHY_CSI2
+	.mipi_sensor_type = MIPI_OPHY_NCSI2,
+	//0,MIPI_SETTLEDELAY_AUTO; 1,MIPI_SETTLEDELAY_MANNUAL
+	.mipi_settle_delay_mode = MIPI_SETTLEDELAY_AUTO,
+	.sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_B,
+	.mclk = 24,
+	.mipi_lane_num = SENSOR_MIPI_2_LANE,
+	.i2c_addr_table = {0x6c, 0xff},
+};
+
+// Sensor output window information
+static struct SENSOR_WINSIZE_INFO_STRUCT imgsensor_winsize_info[OV5648_SUPPORTED_SENSOR_MODE_NUMBER] = {
+	// Preview
+	{
+		1920, 1080, // full_w, full_h
+		   0,    0, // x0_offset, y0_offset
+		1920, 1080, // w0_size, y0_size
+		1920, 1080, // scale_w, scale_h
+		   0,    0, // x1_offset, y1_offset
+		1920, 1080, // w1_size, h1_size
+		   0,    0, // x2_tg_offset, y2_tg_offset
+		1920, 1080  // w2_tg_size, y2_tg_size
+	},
+	// capture
+	{
+		1920, 1080, // full_w, full_h
+		   0,    0, // x0_offset, y0_offset
+		1920, 1080, // w0_size, y0_size
+		1920, 1080, // scale_w, scale_h
+		   0,    0, // x1_offset, y1_offset
+		1920, 1080, // w1_size, h1_size
+		   0,    0, // x2_tg_offset, y2_tg_offset
+		1920, 1080  // w2_tg_size, y2_tg_size
+	},
+	// video
+	{
+		1920, 1080, // full_w, full_h
+		   0,    0, // x0_offset, y0_offset
+		1920, 1080, // w0_size, y0_size
+		1920, 1080, // scale_w, scale_h
+		   0,    0, // x1_offset, y1_offset
+		1920, 1080, // w1_size, h1_size
+		   0,    0, // x2_tg_offset, y2_tg_offset
+		1920, 1080  // w2_tg_size, y2_tg_size
+	},
+	// hight speed video
+	{
+		1920, 1080, // full_w, full_h
+		   0,    0, // x0_offset, y0_offset
+		1920, 1080, // w0_size, y0_size
+		1920, 1080, // scale_w, scale_h
+		   0,    0, // x1_offset, y1_offset
+		1920, 1080, // w1_size, h1_size
+		   0,    0, // x2_tg_offset, y2_tg_offset
+		1920, 1080  // w2_tg_size, y2_tg_size
+	},
+	// slim video
+	{
+		1920, 1080, // full_w, full_h
+		   0,    0, // x0_offset, y0_offset
+		1920, 1080, // w0_size, y0_size
+		1920, 1080, // scale_w, scale_h
+		   0,    0, // x1_offset, y1_offset
+		1920, 1080, // w1_size, h1_size
+		   0,    0, // x2_tg_offset, y2_tg_offset
+		1920, 1080  // w2_tg_size, y2_tg_size
+	},
+};
+
+static struct SENSOR_VC_INFO_STRUCT SENSOR_VC_INFO[3] = {
+	// Preview mode setting
+	{
+		0x01, 0x0a, 0x0000, 0x0008, 0x40,
+		0x00,
+		0x00, 0x2b, 0x0780, 0x0438,
+		0x01, 0x00, 0x0000, 0x0000,
+		0x02, 0x00, 0x0000, 0x0000,
+		0x03, 0x00, 0x0000, 0x0000
+	},
+	// Video mode setting
+	{
+		0x01, 0x0a, 0x0000, 0x0008, 0x40,
+		0x00,
+		0x00, 0x2b, 0x0780, 0x0438,
+		0x01, 0x00, 0x0000, 0x0000,
+		0x02, 0x00, 0x0000, 0x0000,
+		0x03, 0x00, 0x0000, 0x0000
+	},
+	// Capture mode setting
+	{
+		0x01, 0x0a, 0x0000, 0x0008, 0x40,
+		0x00,
+		0x00, 0x2b, 0x0780, 0x0438,
+		0x01, 0x00, 0x0000, 0x0000,
+		0x02, 0x00, 0x0000, 0x0000,
+		0x03, 0x00, 0x0000, 0x0000
+	},
+};
+
+static void set_dummy(struct subdrv_ctx *ctx)
+{
+	LOG_DBG("dummyline = %u, dummypixels = %u ctx->frame_length %u\n",
+		ctx->dummy_line, ctx->dummy_pixel, ctx->frame_length);
+
+	write_cmos_sensor_8(ctx, 0x380e, ctx->frame_length >> 8);
+	write_cmos_sensor_8(ctx, 0x380f, ctx->frame_length & 0xFF);
+	write_cmos_sensor_8(ctx, 0x380c, ctx->line_length >> 8);
+	write_cmos_sensor_8(ctx, 0x380d, ctx->line_length & 0xFF);
+}	//	set_dummy
+
+static void set_max_framerate(struct subdrv_ctx *ctx, UINT16 framerate, kal_bool min_framelength_en)
+{
+	kal_uint32 frame_length = ctx->frame_length;
+	//
+	LOG_DBG("framerate = %u, min framelength should enable = %d\n",
+			framerate, min_framelength_en);
+
+	frame_length = ctx->pclk / framerate * 10 / ctx->line_length;
+	if (frame_length >= ctx->min_frame_length)
+		ctx->frame_length = frame_length;
+	else
+		ctx->frame_length = ctx->min_frame_length;
+	ctx->dummy_line =
+		ctx->frame_length - ctx->min_frame_length;
+	//ctx->dummy_line = dummy_line;
+	//ctx->frame_length = frame_length + ctx->dummy_line;
+	if (ctx->frame_length > imgsensor_info.max_frame_length) {
+		ctx->frame_length = imgsensor_info.max_frame_length;
+		ctx->dummy_line =
+			ctx->frame_length - ctx->min_frame_length;
+	}
+	if (min_framelength_en)
+		ctx->min_frame_length = ctx->frame_length;
+	set_dummy(ctx);
+}	//	set_max_framerate
+
+static void write_shutter(struct subdrv_ctx *ctx, kal_uint16 shutter)
+{
+	kal_uint16 realtime_fps = 0;
+
+	if (shutter > ctx->min_frame_length - imgsensor_info.margin)
+		ctx->frame_length = shutter + imgsensor_info.margin;
+	else
+		ctx->frame_length = ctx->min_frame_length;
+	if (ctx->frame_length > imgsensor_info.max_frame_length)
+		ctx->frame_length = imgsensor_info.max_frame_length;
+	if (shutter < imgsensor_info.min_shutter)
+		shutter = imgsensor_info.min_shutter;
+	//prize fengshangdong modify at 20190112
+
+	if (ctx->autoflicker_en) {
+		realtime_fps = ctx->pclk /
+			ctx->line_length * 10 / ctx->frame_length;
+		if (realtime_fps >= 297 && realtime_fps <= 305)
+			set_max_framerate(ctx, 296, 0);
+		else if (realtime_fps >= 147 && realtime_fps <= 150)
+			set_max_framerate(ctx, 146, 0);
+		else {
+			// Extend frame length
+			write_cmos_sensor_8(ctx, 0x380e, ctx->frame_length >> 8);
+			write_cmos_sensor_8(ctx, 0x380f, ctx->frame_length & 0xFF);
+		}
+	} else {
+		// Extend frame length
+		write_cmos_sensor_8(ctx, 0x380e, ctx->frame_length >> 8);
+		write_cmos_sensor_8(ctx, 0x380f, ctx->frame_length & 0xFF);
+	}
+
+	// Update Shutter
+	write_cmos_sensor_8(ctx, 0x3502, (shutter << 4) & 0xFF);
+	write_cmos_sensor_8(ctx, 0x3501, (shutter >> 4) & 0xFF);
+	write_cmos_sensor_8(ctx, 0x3500, (shutter >> 12) & 0x0F);
+
+	LOG_DBG("shutter =%u, framelength =%u\n", shutter, ctx->frame_length);
+}	//	write_shutter
+
+/*************************************************************************
+ * FUNCTION
+ * set_shutter
+ *
+ * DESCRIPTION
+ * This function set e-shutter of sensor to change exposure time.
+ *
+ * PARAMETERS
+ * iShutter : exposured lines
+ *
+ * RETURNS
+ * None
+ *
+ * GLOBALS AFFECTED
+ *
+ *************************************************************************/
+static void set_shutter(struct subdrv_ctx *ctx, kal_uint16 shutter)
+{
+	ctx->shutter = shutter;
+
+	write_shutter(ctx, shutter);
+} // set_shutter
+
+static kal_uint16 gain2reg(struct subdrv_ctx *ctx, const kal_uint32 gain)
+{
+	const int reg_gain_max = 1023; // the interval is [0, 1023].
+	kal_uint8 i = 0;
+	kal_uint16 reg_gain = 0x0;
+
+	reg_gain = reg_gain_max * (gain - MIN_GAIN) / (MAX_GAIN - MIN_GAIN);
+
+	LOG_INF("%s: map HAL gain %d to reg value %d (0x%x)\n", __func__, gain, reg_gain, reg_gain);
+
+	return (kal_uint16) reg_gain;
+}
+
+/*************************************************************************
+ * FUNCTION
+ * set_gain
+ *
+ * DESCRIPTION
+ * This function is to set global gain to sensor.
+ *
+ * PARAMETERS
+ * iGain : sensor global gain(base: 0x40)
+ *
+ * RETURNS
+ * the actually gain set to sensor.
+ *
+ * GLOBALS AFFECTED
+ *
+ *************************************************************************/
+static kal_uint32 set_gain(struct subdrv_ctx *ctx, kal_uint32 gain)
+{
+	kal_uint16 reg_gain;
+
+	gain = min(gain, MAX_GAIN);
+	gain = max(gain, MIN_GAIN);
+	
+	reg_gain = gain2reg(ctx, gain);
+	ctx->gain = reg_gain;
+
+	write_cmos_sensor_8(ctx, 0x350a, reg_gain >> 8);
+	write_cmos_sensor_8(ctx, 0x350b, reg_gain & 0xFF);
+
+	LOG_DBG("gain = %u, reg_gain = 0x%x\n", gain, reg_gain);
+
+	return gain;
+}	//	set_gain
+
+static void ihdr_write_shutter_gain(struct subdrv_ctx *ctx, kal_uint16 le,
+		kal_uint16 se, kal_uint16 gain)
+{
+	kal_uint16 realtime_fps = 0;
+	//kal_uint32 frame_length = 0;
+	kal_uint16 reg_gain;
+
+	LOG_DBG("le:0x%x, se:0x%x, gain:0x%x\n", le, se, gain);
+	if (le > ctx->min_frame_length - imgsensor_info.margin)
+		ctx->frame_length = le + imgsensor_info.margin;
+	else
+		ctx->frame_length = ctx->min_frame_length;
+	if (ctx->frame_length > imgsensor_info.max_frame_length)
+		ctx->frame_length = imgsensor_info.max_frame_length;
+	if (le < imgsensor_info.min_shutter)
+		le = imgsensor_info.min_shutter;
+	if (ctx->autoflicker_en) {
+		realtime_fps = ctx->pclk /
+			ctx->line_length * 10 / ctx->frame_length;
+		if (realtime_fps >= 297 && realtime_fps <= 305)
+			set_max_framerate(ctx, 296, 0);
+		else if (realtime_fps >= 147 && realtime_fps <= 150)
+			set_max_framerate(ctx, 146, 0);
+		else {
+			write_cmos_sensor_8(ctx, 0x380e, ctx->frame_length >> 8);
+			write_cmos_sensor_8(ctx, 0x380f, ctx->frame_length & 0xFF);
+		}
+	} else {
+		write_cmos_sensor_8(ctx, 0x380e, ctx->frame_length >> 8);
+		write_cmos_sensor_8(ctx, 0x380f, ctx->frame_length & 0xFF);
+	}
+
+	// Long exposure
+	// register configurations here.
+
+	// Short exposure
+	// register configurations here.
+
+	// analogue gain.
+	reg_gain = gain2reg(ctx, gain);
+	ctx->gain = reg_gain;
+	write_cmos_sensor_8(ctx, 0x350a, reg_gain >> 8);
+	write_cmos_sensor_8(ctx, 0x350b, reg_gain & 0xFF);
+}
+
+static void ihdr_write_shutter(struct subdrv_ctx *ctx, kal_uint16 le, kal_uint16 se)
+{
+	kal_uint16 realtime_fps = 0;
+	//kal_uint32 frame_length = 0;
+	//kal_uint16 reg_gain;
+	LOG_DBG("le:0x%x, se:0x%x\n", le, se);
+	if (le > ctx->min_frame_length - imgsensor_info.margin)
+		ctx->frame_length = le + imgsensor_info.margin;
+	else
+		ctx->frame_length = ctx->min_frame_length;
+	if (ctx->frame_length > imgsensor_info.max_frame_length)
+		ctx->frame_length = imgsensor_info.max_frame_length;
+	if (le < imgsensor_info.min_shutter)
+		le = imgsensor_info.min_shutter;
+	 //prize fengshangdong modify at 20190111 for camera ITS test
+	if (ctx->autoflicker_en) {
+		realtime_fps = ctx->pclk /
+			ctx->line_length * 10 / ctx->frame_length;
+		if (realtime_fps >= 297 && realtime_fps <= 305)
+			set_max_framerate(ctx, 296, 0);
+		else if (realtime_fps >= 147 && realtime_fps <= 150)
+			set_max_framerate(ctx, 146, 0);
+		else {
+			write_cmos_sensor_8(ctx, 0x380e, ctx->frame_length >> 8);
+			write_cmos_sensor_8(ctx, 0x380f, ctx->frame_length & 0xFF);
+		}
+	} else {
+		write_cmos_sensor_8(ctx, 0x380e, ctx->frame_length >> 8);
+		write_cmos_sensor_8(ctx, 0x380f, ctx->frame_length & 0xFF);
+	}
+
+	// Long exposure
+	// register configurations here.
+
+	// Short exposure
+	// register configurations here.
+}
+
+static void set_mirror_flip(struct subdrv_ctx *ctx, kal_uint8 image_mirror)
+{
+}
+
+/*************************************************************************
+ * FUNCTION
+ * night_mode
+ *
+ * DESCRIPTION
+ * This function night mode of sensor.
+ *
+ * PARAMETERS
+ * bEnable: KAL_TRUE -> enable night mode, otherwise, disable night mode
+ *
+ * RETURNS
+ * None
+ *
+ * GLOBALS AFFECTED
+ *
+ *************************************************************************/
+static void night_mode(struct subdrv_ctx *ctx, kal_bool enable)
+{
+//No Need to implement this function
+} // night_mode
+
+static void sensor_init(struct subdrv_ctx *ctx)
+{
+	LOG_INFO("E\n");
+
+	// @@ global setting
+	write_cmos_sensor_8(ctx, 0x0100, 0x00);	// Software Standy
+	write_cmos_sensor_8(ctx, 0x0103, 0x01);	// Software Reset
+
+	mdelay(5);
+
+	write_cmos_sensor_8(ctx, 0x3001, 0x00);	// D[7:0] set to input
+	write_cmos_sensor_8(ctx, 0x3002, 0x00);	// D[11:8] set to input
+	write_cmos_sensor_8(ctx, 0x3011, 0x02);	// Drive strength 2x
+
+	write_cmos_sensor_8(ctx, 0x3018, 0x4c);	// MIPI 2 lane
+	write_cmos_sensor_8(ctx, 0x3022, 0x00);
+
+	write_cmos_sensor_8(ctx, 0x3034, 0x1a);	// 10-bit mode
+	write_cmos_sensor_8(ctx, 0x3035, 0x21);	// PLL
+	write_cmos_sensor_8(ctx, 0x3036, 0x69);	// PLL
+
+	write_cmos_sensor_8(ctx, 0x3037, 0x03);	// PLL
+
+	write_cmos_sensor_8(ctx, 0x3038, 0x00);	// PLL
+	write_cmos_sensor_8(ctx, 0x3039, 0x00);	// PLL
+	write_cmos_sensor_8(ctx, 0x303a, 0x00);	// PLLS
+	write_cmos_sensor_8(ctx, 0x303b, 0x19);	// PLLS
+	write_cmos_sensor_8(ctx, 0x303c, 0x11);	// PLLS
+	write_cmos_sensor_8(ctx, 0x303d, 0x30);	// PLLS
+	write_cmos_sensor_8(ctx, 0x3105, 0x11);
+	write_cmos_sensor_8(ctx, 0x3106, 0x05);	// PLL
+	write_cmos_sensor_8(ctx, 0x3304, 0x28);
+	write_cmos_sensor_8(ctx, 0x3305, 0x41);
+	write_cmos_sensor_8(ctx, 0x3306, 0x30);
+	write_cmos_sensor_8(ctx, 0x3308, 0x00);
+	write_cmos_sensor_8(ctx, 0x3309, 0xc8);
+	write_cmos_sensor_8(ctx, 0x330a, 0x01);
+	write_cmos_sensor_8(ctx, 0x330b, 0x90);
+	write_cmos_sensor_8(ctx, 0x330c, 0x02);
+	write_cmos_sensor_8(ctx, 0x330d, 0x58);
+	write_cmos_sensor_8(ctx, 0x330e, 0x03);
+	write_cmos_sensor_8(ctx, 0x330f, 0x20);
+	write_cmos_sensor_8(ctx, 0x3300, 0x00);
+
+	write_cmos_sensor_8(ctx, 0x3503, 0x07);
+
+	// gain
+	write_cmos_sensor_8(ctx, 0x350a, 0x00);	// gain[9:8]
+	write_cmos_sensor_8(ctx, 0x350b, 0x40);	// gain[7:0], gain = 4x
+
+	write_cmos_sensor_8(ctx, 0x3601, 0x33);	// analog control
+	write_cmos_sensor_8(ctx, 0x3602, 0x00);	// analog control
+	write_cmos_sensor_8(ctx, 0x3611, 0x0e);	// analog control
+	write_cmos_sensor_8(ctx, 0x3612, 0x2b);	// analog control
+	write_cmos_sensor_8(ctx, 0x3614, 0x50);	// analog control
+	write_cmos_sensor_8(ctx, 0x3620, 0x33);	// analog control
+	write_cmos_sensor_8(ctx, 0x3622, 0x00);	// analog control
+	write_cmos_sensor_8(ctx, 0x3630, 0xad);	// analog control
+	write_cmos_sensor_8(ctx, 0x3631, 0x00);	// analog control
+	write_cmos_sensor_8(ctx, 0x3632, 0x94);	// analog control
+	write_cmos_sensor_8(ctx, 0x3633, 0x17);	// analog control
+	write_cmos_sensor_8(ctx, 0x3634, 0x14);	// analog control
+
+	// fix EV3 issue
+	write_cmos_sensor_8(ctx, 0x3704, 0xc0);	// analog control
+
+	write_cmos_sensor_8(ctx, 0x3705, 0x2a);	// analog control
+	write_cmos_sensor_8(ctx, 0x3708, 0x66);	// analog control
+	write_cmos_sensor_8(ctx, 0x3709, 0x52);	// analog control
+	write_cmos_sensor_8(ctx, 0x370b, 0x23);	// analog control
+	write_cmos_sensor_8(ctx, 0x370c, 0xc3);	// analog control
+	write_cmos_sensor_8(ctx, 0x370d, 0x00);	// analog control
+	write_cmos_sensor_8(ctx, 0x370e, 0x00);	// analog control
+	write_cmos_sensor_8(ctx, 0x371c, 0x07);	// analog control
+	write_cmos_sensor_8(ctx, 0x3739, 0xd2);	// analog control
+	write_cmos_sensor_8(ctx, 0x373c, 0x00);
+
+	write_cmos_sensor_8(ctx, 0x3800, 0x00);	// xstart = 0
+	write_cmos_sensor_8(ctx, 0x3801, 0x00);	// xstart
+	write_cmos_sensor_8(ctx, 0x3802, 0x00);	// ystart = 0
+	write_cmos_sensor_8(ctx, 0x3803, 0x00);	// ystart
+	write_cmos_sensor_8(ctx, 0x3804, 0x0a);	// xend = 2623
+	write_cmos_sensor_8(ctx, 0x3805, 0x3f);	// yend
+	write_cmos_sensor_8(ctx, 0x3806, 0x07);	// yend = 1955
+	write_cmos_sensor_8(ctx, 0x3807, 0xa3);	// yend
+	write_cmos_sensor_8(ctx, 0x3808, 0x05);	// x output size = 1296
+	write_cmos_sensor_8(ctx, 0x3809, 0x10);	// x output size
+	write_cmos_sensor_8(ctx, 0x380a, 0x03);	// y output size = 972
+	write_cmos_sensor_8(ctx, 0x380b, 0xcc);	// y output size
+	write_cmos_sensor_8(ctx, 0x380c, 0x0b);	// hts = 2816
+	write_cmos_sensor_8(ctx, 0x380d, 0x00);	// hts
+	write_cmos_sensor_8(ctx, 0x380e, 0x03);	// vts = 992
+	write_cmos_sensor_8(ctx, 0x380f, 0xe0);	// vts
+
+	write_cmos_sensor_8(ctx, 0x3810, 0x00);	// isp x win = 8
+	write_cmos_sensor_8(ctx, 0x3811, 0x08);	// isp x win
+	write_cmos_sensor_8(ctx, 0x3812, 0x00);	// isp y win = 4
+	write_cmos_sensor_8(ctx, 0x3813, 0x04);	// isp y win
+	write_cmos_sensor_8(ctx, 0x3814, 0x31);	// x inc
+	write_cmos_sensor_8(ctx, 0x3815, 0x31);	// y inc
+	write_cmos_sensor_8(ctx, 0x3817, 0x00);	// hsync start
+
+	// Horizontal binning
+	write_cmos_sensor_8(ctx, 0x3820, 0x08);	// flip off, v bin off
+	write_cmos_sensor_8(ctx, 0x3821, 0x07);	// mirror on, h bin on
+
+	write_cmos_sensor_8(ctx, 0x3826, 0x03);
+	write_cmos_sensor_8(ctx, 0x3829, 0x00);
+	write_cmos_sensor_8(ctx, 0x382b, 0x0b);
+	write_cmos_sensor_8(ctx, 0x3830, 0x00);
+	write_cmos_sensor_8(ctx, 0x3836, 0x00);
+	write_cmos_sensor_8(ctx, 0x3837, 0x00);
+	write_cmos_sensor_8(ctx, 0x3838, 0x00);
+	write_cmos_sensor_8(ctx, 0x3839, 0x04);
+	write_cmos_sensor_8(ctx, 0x383a, 0x00);
+	write_cmos_sensor_8(ctx, 0x383b, 0x01);
+
+	write_cmos_sensor_8(ctx, 0x3b00, 0x00);	// strobe off
+	write_cmos_sensor_8(ctx, 0x3b02, 0x08);	// shutter delay
+	write_cmos_sensor_8(ctx, 0x3b03, 0x00);	// shutter delay
+	write_cmos_sensor_8(ctx, 0x3b04, 0x04);	// frex_exp
+	write_cmos_sensor_8(ctx, 0x3b05, 0x00);	// frex_exp
+	write_cmos_sensor_8(ctx, 0x3b06, 0x04);
+	write_cmos_sensor_8(ctx, 0x3b07, 0x08);	// frex inv
+	write_cmos_sensor_8(ctx, 0x3b08, 0x00);	// frex exp req
+	write_cmos_sensor_8(ctx, 0x3b09, 0x02);	// frex end option
+	write_cmos_sensor_8(ctx, 0x3b0a, 0x04);	// frex rst length
+	write_cmos_sensor_8(ctx, 0x3b0b, 0x00);	// frex strobe width
+	write_cmos_sensor_8(ctx, 0x3b0c, 0x3d);	// frex strobe width
+	write_cmos_sensor_8(ctx, 0x3f01, 0x0d);
+	write_cmos_sensor_8(ctx, 0x3f0f, 0xf5);
+
+	write_cmos_sensor_8(ctx, 0x4000, 0x89);	// blc enable
+	write_cmos_sensor_8(ctx, 0x4001, 0x02);	// blc start line
+	write_cmos_sensor_8(ctx, 0x4002, 0x45);
+	write_cmos_sensor_8(ctx, 0x4004, 0x02);	// black line number
+	write_cmos_sensor_8(ctx, 0x4005, 0x18);	// blc normal freeze
+	write_cmos_sensor_8(ctx, 0x4006, 0x08);
+	write_cmos_sensor_8(ctx, 0x4007, 0x10);
+	write_cmos_sensor_8(ctx, 0x4008, 0x00);
+	write_cmos_sensor_8(ctx, 0x4300, 0xf8);
+	write_cmos_sensor_8(ctx, 0x4303, 0xff);
+	write_cmos_sensor_8(ctx, 0x4304, 0x00);
+	write_cmos_sensor_8(ctx, 0x4307, 0xff);
+	write_cmos_sensor_8(ctx, 0x4520, 0x00);
+	write_cmos_sensor_8(ctx, 0x4521, 0x00);
+	write_cmos_sensor_8(ctx, 0x4511, 0x22);
+
+	// update DPC settings
+	write_cmos_sensor_8(ctx, 0x5780, 0xfc);
+	write_cmos_sensor_8(ctx, 0x5781, 0x1f);
+	write_cmos_sensor_8(ctx, 0x5782, 0x03);
+	write_cmos_sensor_8(ctx, 0x5786, 0x20);
+	write_cmos_sensor_8(ctx, 0x5787, 0x40);
+	write_cmos_sensor_8(ctx, 0x5788, 0x08);
+	write_cmos_sensor_8(ctx, 0x5789, 0x08);
+	write_cmos_sensor_8(ctx, 0x578a, 0x02);
+	write_cmos_sensor_8(ctx, 0x578b, 0x01);
+	write_cmos_sensor_8(ctx, 0x578c, 0x01);
+	write_cmos_sensor_8(ctx, 0x578d, 0x0c);
+	write_cmos_sensor_8(ctx, 0x578e, 0x02);
+	write_cmos_sensor_8(ctx, 0x578f, 0x01);
+	write_cmos_sensor_8(ctx, 0x5790, 0x01);
+
+	write_cmos_sensor_8(ctx, 0x4800, 0x24);	// MIPI line sync enable
+
+	write_cmos_sensor_8(ctx, 0x481f, 0x3c);	// MIPI clk prepare min
+	write_cmos_sensor_8(ctx, 0x4826, 0x00);	// MIPI hs prepare min
+	write_cmos_sensor_8(ctx, 0x4837, 0x18);	// MIPI global timing
+	write_cmos_sensor_8(ctx, 0x4b00, 0x06);
+	write_cmos_sensor_8(ctx, 0x4b01, 0x0a);
+	write_cmos_sensor_8(ctx, 0x5000, 0xff);	// bpc on, wpc on
+	write_cmos_sensor_8(ctx, 0x5001, 0x00);	// awb disable
+	write_cmos_sensor_8(ctx, 0x5002, 0x41);
+	write_cmos_sensor_8(ctx, 0x5003, 0x0a);	// buf en, bin auto en
+	write_cmos_sensor_8(ctx, 0x5004, 0x00);	// size man off
+	write_cmos_sensor_8(ctx, 0x5043, 0x00);
+	write_cmos_sensor_8(ctx, 0x5013, 0x00);
+	write_cmos_sensor_8(ctx, 0x501f, 0x03);	// ISP output data
+	write_cmos_sensor_8(ctx, 0x503d, 0x00);	// test pattern off
+	write_cmos_sensor_8(ctx, 0x5180, 0x08);	// manual wb gain on
+	write_cmos_sensor_8(ctx, 0x5a00, 0x08);
+	write_cmos_sensor_8(ctx, 0x5b00, 0x01);
+	write_cmos_sensor_8(ctx, 0x5b01, 0x40);
+	write_cmos_sensor_8(ctx, 0x5b02, 0x00);
+	write_cmos_sensor_8(ctx, 0x5b03, 0xf0);
+
+	write_cmos_sensor_8(ctx, 0x4837, 0x17);	// MIPI global timing
+} // sensor_init
+
+static void video_1080p_setting(struct subdrv_ctx *ctx) {
+
+	/********************************************************
+	 *
+	 *   1080p 30fps 2 lane MIPI 420Mbps/lane
+	 *    @@1080p
+	 *    ;;pclk=84M,HTS=2500,VTS=1120
+	 ********************************************************/
+
+	LOG_INF("E\n");
+
+	write_cmos_sensor_8(ctx, 0x0100, 0x00);	// Stream Off
+
+	write_cmos_sensor_8(ctx, 0x3500, 0x00);	// exposure [19:16]
+	write_cmos_sensor_8(ctx, 0x3501, 0x45);	// exposure
+	write_cmos_sensor_8(ctx, 0x3502, 0xc0);	// exposure
+
+	write_cmos_sensor_8(ctx, 0x3708, 0x63);
+
+	write_cmos_sensor_8(ctx, 0x3709, 0x12);
+	write_cmos_sensor_8(ctx, 0x370c, 0xcc);
+	write_cmos_sensor_8(ctx, 0x3800, 0x01);	// x start = 336
+	write_cmos_sensor_8(ctx, 0x3801, 0x50);	// x start
+	write_cmos_sensor_8(ctx, 0x3802, 0x01);	// y start = 434
+	write_cmos_sensor_8(ctx, 0x3803, 0xb2);	// y start
+	write_cmos_sensor_8(ctx, 0x3804, 0x08);	// xend = 2287
+	write_cmos_sensor_8(ctx, 0x3805, 0xef);	// xend
+	write_cmos_sensor_8(ctx, 0x3806, 0x05);	// yend = 1521
+	write_cmos_sensor_8(ctx, 0x3807, 0xf1);	// yend
+	write_cmos_sensor_8(ctx, 0x3808, 0x07);	// x output size = 1920
+	write_cmos_sensor_8(ctx, 0x3809, 0x80);	// x output size
+	write_cmos_sensor_8(ctx, 0x380a, 0x04);	// y output size = 1080
+	write_cmos_sensor_8(ctx, 0x380b, 0x38);	// y output size
+
+	write_cmos_sensor_8(ctx, 0x380c, ((imgsensor_info.hs_video.linelength >> 8) & 0xFF));
+	write_cmos_sensor_8(ctx, 0x380d, (imgsensor_info.hs_video.linelength & 0xFF));	// hts
+	write_cmos_sensor_8(ctx, 0x380e, ((imgsensor_info.hs_video.framelength >> 8) & 0xFF));
+	write_cmos_sensor_8(ctx, 0x380f, (imgsensor_info.hs_video.framelength & 0xFF));	// vts
+
+	write_cmos_sensor_8(ctx, 0x3810, 0x00);	// isp x win = 16
+	write_cmos_sensor_8(ctx, 0x3811, 0x10);	// isp x win
+	write_cmos_sensor_8(ctx, 0x3812, 0x00);	// isp y win = 4
+	write_cmos_sensor_8(ctx, 0x3813, 0x04);	// isp y win
+	write_cmos_sensor_8(ctx, 0x3814, 0x11);	// x inc
+	write_cmos_sensor_8(ctx, 0x3815, 0x11);	// y inc
+	write_cmos_sensor_8(ctx, 0x3817, 0x00);	// hsync start
+
+	/********************************************************
+	 *
+	 *   0x3820[2] ISP Vertical flip
+	 *   0x3820[1] Sensor Vertical flip
+	 *
+	 *   0x3821[2] ISP Horizontal mirror
+	 *   0x3821[1] Sensor Horizontal mirror
+	 *
+	 *   ISP and Sensor flip or mirror register bit should be the same!!
+	 *
+	 ********************************************************/
+	write_cmos_sensor_8(ctx, 0x3820, 0x40);	// flip off, v bin off
+	write_cmos_sensor_8(ctx, 0x3821, 0x06);	// mirror on, h bin on
+
+
+	write_cmos_sensor_8(ctx, 0x4004, 0x04);	// black line number
+	write_cmos_sensor_8(ctx, 0x4005, 0x18);	// blc normal freeze
+
+	write_cmos_sensor_8(ctx, 0x4837, 0x18);	// MIPI global timing
+
+	write_cmos_sensor_8(ctx, 0x0100, 0x01);	// Stream On
+}
+
+static void preview_setting(struct subdrv_ctx *ctx)
+{
+	LOG_INF("enter\n");
+	video_1080p_setting(ctx);
+}   //  preview_setting
+
+static void preview_setting_HDR(struct subdrv_ctx *ctx)
+{
+	LOG_INF("enter\n");
+	video_1080p_setting(ctx);
+} // preview_setting
+
+static void capture_setting(struct subdrv_ctx *ctx, kal_uint16 currefps)
+{
+	LOG_INF("enter\n");
+	video_1080p_setting(ctx);
+}
+
+static void normal_video_setting(struct subdrv_ctx *ctx, kal_uint16 currefps)
+{
+	LOG_INF("enter\n");
+	video_1080p_setting(ctx);
+}
+
+static void fullsize_setting_HDR(struct subdrv_ctx *ctx, kal_uint16 currefps)
+{
+	LOG_INF("enter\n");
+	video_1080p_setting(ctx);
+}
+
+static void hs_video_setting(struct subdrv_ctx *ctx)
+{
+	LOG_INF("enter\n");
+	video_1080p_setting(ctx);
+}
+
+static void slim_video_setting(struct subdrv_ctx *ctx)
+{
+	LOG_INF("enter\n");
+	video_1080p_setting(ctx);
+}
+
+static kal_uint32 return_sensor_id(struct subdrv_ctx *ctx) {
+	return ((read_cmos_sensor_8(ctx, 0x300A) << 8) | read_cmos_sensor_8(ctx, 0x300B));
+}
+
+/*************************************************************************
+ * FUNCTION
+ * get_imgsensor_id
+ *
+ * DESCRIPTION
+ * This function get the sensor ID
+ *
+ * PARAMETERS
+ * *sensorID : return the sensor ID
+ *
+ * RETURNS
+ * None
+ *
+ * GLOBALS AFFECTED
+ *
+ *************************************************************************/
+static int get_imgsensor_id(struct subdrv_ctx *ctx, UINT32 *sensor_id)
+{
+	kal_uint8 i = 0;
+	kal_uint8 retry = 2;
+	//sensor have two i2c address 0x6c 0x6d & 0x21 0x20,
+	//we should detect the module used i2c address
+	while (imgsensor_info.i2c_addr_table[i] != 0xff) {
+		ctx->i2c_write_id = imgsensor_info.i2c_addr_table[i];
+		do {
+			*sensor_id = return_sensor_id(ctx);
+			if (*sensor_id == imgsensor_info.sensor_id) {
+				LOG_INFO("OV5648 i2c write id: 0x%x, sensor id: 0x%x\n",
+					ctx->i2c_write_id, *sensor_id);
+				return ERROR_NONE;
+			}
+			LOG_DBG("OV5648 Read sensor id fail, write id:0x%x id: 0x%x\n",
+				ctx->i2c_write_id, *sensor_id);
+			retry--;
+		} while (retry > 0);
+		i++;
+		if (*sensor_id == imgsensor_info.sensor_id)
+			break;
+		retry = 2;
+	}
+	if (*sensor_id != imgsensor_info.sensor_id) {
+		// if Sensor ID is not correct,
+		// Must set *sensor_id to 0xFFFFFFFF
+		LOG_ERR("Get OV5648 sensor id fail.");
+		*sensor_id = 0xFFFFFFFF;
+		return ERROR_SENSOR_CONNECT_FAIL;
+	}
+	return ERROR_NONE;
+}
+
+/*************************************************************************
+ * FUNCTION
+ * open
+ *
+ * DESCRIPTION
+ * This function initialize the registers of CMOS sensor
+ *
+ * PARAMETERS
+ * None
+ *
+ * RETURNS
+ * None
+ *
+ * GLOBALS AFFECTED
+ *
+ *************************************************************************/
+static int open(struct subdrv_ctx *ctx)
+{
+	kal_uint32 sensor_id = 0;
+	kal_int32 ret;
+
+	LOG_INFO("E\n");
+	ret = get_imgsensor_id(ctx, &sensor_id);
+	if (ret != ERROR_NONE)
+		return ret;
+
+	// initail sequence write in
+	sensor_init(ctx);
+
+	ctx->autoflicker_en = KAL_FALSE;
+	ctx->sensor_mode = IMGSENSOR_MODE_INIT;
+	ctx->shutter = 0x3D0;
+	ctx->gain = MAX_GAIN;
+	ctx->pclk = imgsensor_info.pre.pclk;
+	ctx->frame_length = imgsensor_info.pre.framelength;
+	ctx->line_length = imgsensor_info.pre.linelength;
+	ctx->min_frame_length = imgsensor_info.pre.framelength;
+	ctx->dummy_pixel = 0;
+	ctx->dummy_line = 0;
+	ctx->ihdr_mode = 0;
+	ctx->test_pattern = KAL_FALSE;
+	ctx->current_fps = imgsensor_info.pre.max_framerate;
+
+	return ERROR_NONE;
+} // open
+
+/*************************************************************************
+ * FUNCTION
+ * close
+ *
+ * DESCRIPTION
+ *
+ *
+ * PARAMETERS
+ * None
+ *
+ * RETURNS
+ * None
+ *
+ * GLOBALS AFFECTED
+ *
+ *************************************************************************/
+static int close(struct subdrv_ctx *ctx)
+{
+	LOG_INFO("E\n");
+
+	//No Need to implement this function
+
+	return ERROR_NONE;
+} // close
+
+/*************************************************************************
+ * FUNCTION
+ * preview
+ *
+ * DESCRIPTION
+ * This function start the sensor preview.
+ *
+ * PARAMETERS
+ * *image_window : address pointer of pixel numbers in one period of HSYNC
+ *  *sensor_config_data : address pointer of line numbers in one period of VSYNC
+ *
+ * RETURNS
+ * None
+ *
+ * GLOBALS AFFECTED
+ *
+ *************************************************************************/
+static kal_uint32 preview(struct subdrv_ctx *ctx, MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+		MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+	LOG_INFO("E\n");
+
+	ctx->sensor_mode = IMGSENSOR_MODE_PREVIEW;
+	ctx->pclk = imgsensor_info.pre.pclk;
+	//ctx->video_mode = KAL_FALSE;
+	ctx->line_length = imgsensor_info.pre.linelength;
+	ctx->frame_length = imgsensor_info.pre.framelength;
+	ctx->min_frame_length = imgsensor_info.pre.framelength;
+	ctx->autoflicker_en = KAL_FALSE;
+	if ((ctx->ihdr_mode == 2) || (ctx->ihdr_mode == 9))
+		preview_setting_HDR(ctx);
+	else
+		preview_setting(ctx);
+	return ERROR_NONE;
+} // preview
+
+/*************************************************************************
+ * FUNCTION
+ * capture
+ *
+ * DESCRIPTION
+ * This function setup the CMOS sensor in capture MY_OUTPUT mode
+ *
+ * PARAMETERS
+ *
+ * RETURNS
+ * None
+ *
+ * GLOBALS AFFECTED
+ *
+ *************************************************************************/
+static kal_uint32 capture(struct subdrv_ctx *ctx, MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+		MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+	LOG_INFO("E\n");
+	ctx->sensor_mode = IMGSENSOR_MODE_CAPTURE;
+	if (ctx->current_fps == imgsensor_info.cap1.max_framerate) {
+		//PIP capture: 24fps for less than 13M,
+		//20fps for 16M,15fps for 20M
+		ctx->pclk = imgsensor_info.cap1.pclk;
+		ctx->line_length = imgsensor_info.cap1.linelength;
+		ctx->frame_length = imgsensor_info.cap1.framelength;
+		ctx->min_frame_length = imgsensor_info.cap1.framelength;
+		ctx->autoflicker_en = KAL_FALSE;
+	}  else if (ctx->current_fps ==
+			imgsensor_info.cap2.max_framerate) {
+		if (ctx->current_fps != imgsensor_info.cap.max_framerate)
+			LOG_WARN(
+			"Warning: current_fps %u fps is not support,so use cap1's setting: %u fps!\n",
+				ctx->current_fps,
+				imgsensor_info.cap1.max_framerate/10);
+		ctx->pclk = imgsensor_info.cap2.pclk;
+		ctx->line_length = imgsensor_info.cap2.linelength;
+		ctx->frame_length = imgsensor_info.cap2.framelength;
+		ctx->min_frame_length = imgsensor_info.cap2.framelength;
+		ctx->autoflicker_en = KAL_FALSE;
+	} else {
+		if (ctx->current_fps != imgsensor_info.cap.max_framerate)
+			LOG_WARN(
+			"Warning: current_fps %u fps is not support,so use cap1's setting: %u fps!\n",
+				ctx->current_fps,
+				imgsensor_info.cap1.max_framerate/10);
+		ctx->pclk = imgsensor_info.cap.pclk;
+		ctx->line_length = imgsensor_info.cap.linelength;
+		ctx->frame_length = imgsensor_info.cap.framelength;
+		ctx->min_frame_length = imgsensor_info.cap.framelength;
+		ctx->autoflicker_en = KAL_FALSE;
+	}
+	//
+	if ((ctx->ihdr_mode == 2) || (ctx->ihdr_mode == 9))
+		fullsize_setting_HDR(ctx, ctx->current_fps);
+	else
+		capture_setting(ctx, 300);
+		//capture_setting(ctx, ctx->current_fps);
+
+	return ERROR_NONE;
+}	// capture(ctx)
+static kal_uint32 normal_video(struct subdrv_ctx *ctx,
+		MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+		MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+	LOG_INFO("E\n");
+
+	ctx->sensor_mode = IMGSENSOR_MODE_VIDEO;
+	ctx->pclk = imgsensor_info.normal_video.pclk;
+	ctx->line_length = imgsensor_info.normal_video.linelength;
+	ctx->frame_length = imgsensor_info.normal_video.framelength;
+	ctx->min_frame_length = imgsensor_info.normal_video.framelength;
+	//ctx->current_fps = 300;
+	ctx->autoflicker_en = KAL_FALSE;
+	if (ctx->ihdr_mode == 2)
+		fullsize_setting_HDR(ctx, ctx->current_fps);
+	else
+		normal_video_setting(ctx, ctx->current_fps);
+	return ERROR_NONE;
+} // normal_video
+
+static kal_uint32 hs_video(struct subdrv_ctx *ctx, MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+		MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+	LOG_INFO("E\n");
+
+	ctx->sensor_mode = IMGSENSOR_MODE_HIGH_SPEED_VIDEO;
+	ctx->pclk = imgsensor_info.hs_video.pclk;
+	//ctx->video_mode = KAL_TRUE;
+	ctx->line_length = imgsensor_info.hs_video.linelength;
+	ctx->frame_length = imgsensor_info.hs_video.framelength;
+	ctx->min_frame_length = imgsensor_info.hs_video.framelength;
+	ctx->dummy_line = 0;
+	ctx->dummy_pixel = 0;
+	//ctx->current_fps = 300;
+	ctx->autoflicker_en = KAL_FALSE;
+	hs_video_setting(ctx);
+	return ERROR_NONE;
+} // hs_video
+
+static kal_uint32 slim_video(struct subdrv_ctx *ctx,
+			MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+			MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+	LOG_INFO("E\n");
+
+	ctx->sensor_mode = IMGSENSOR_MODE_SLIM_VIDEO;
+	ctx->pclk = imgsensor_info.slim_video.pclk;
+	//ctx->video_mode = KAL_TRUE;
+	ctx->line_length = imgsensor_info.slim_video.linelength;
+	ctx->frame_length = imgsensor_info.slim_video.framelength;
+	ctx->min_frame_length = imgsensor_info.slim_video.framelength;
+	ctx->dummy_line = 0;
+	ctx->dummy_pixel = 0;
+	//ctx->current_fps = 300;
+	ctx->autoflicker_en = KAL_FALSE;
+	slim_video_setting(ctx);
+	return ERROR_NONE;
+} // slim_video
+
+static int get_resolution(struct subdrv_ctx *ctx,
+		MSDK_SENSOR_RESOLUTION_INFO_STRUCT *sensor_resolution)
+{
+	int i = 0;
+
+	for (i = SENSOR_SCENARIO_ID_MIN; i < SENSOR_SCENARIO_ID_MAX; i++) {
+		if (i < ARRAY_SIZE(imgsensor_winsize_info)) {
+			sensor_resolution->SensorWidth[i] = imgsensor_winsize_info[i].w2_tg_size;
+			sensor_resolution->SensorHeight[i] = imgsensor_winsize_info[i].h2_tg_size;
+		} else {
+			sensor_resolution->SensorWidth[i] = 0;
+			sensor_resolution->SensorHeight[i] = 0;
+		}
+	}
+
+	return ERROR_NONE;
+} // get_resolution
+
+static int get_info(struct subdrv_ctx *ctx, enum MSDK_SCENARIO_ID_ENUM scenario_id,
+	MSDK_SENSOR_INFO_STRUCT *sensor_info,
+	MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+	LOG_DBG("scenario_id = %d\n", scenario_id);
+
+	sensor_info->SensorClockPolarity = SENSOR_CLOCK_POLARITY_LOW;
+	 // not use
+	sensor_info->SensorClockFallingPolarity = SENSOR_CLOCK_POLARITY_LOW;
+	sensor_info->SensorHsyncPolarity =
+		SENSOR_CLOCK_POLARITY_LOW;// inverse with datasheet
+	sensor_info->SensorVsyncPolarity = SENSOR_CLOCK_POLARITY_LOW;
+	sensor_info->SensorInterruptDelayLines = 4; // not use
+	sensor_info->SensorResetActiveHigh = FALSE; // not use
+	sensor_info->SensorResetDelayCount = 5; // not use
+
+	sensor_info->SensroInterfaceType = imgsensor_info.sensor_interface_type;
+	sensor_info->MIPIsensorType = imgsensor_info.mipi_sensor_type;
+	//sensor_info->SettleDelayMode = imgsensor_info.mipi_settle_delay_mode;
+	sensor_info->SensorOutputDataFormat =
+		imgsensor_info.sensor_output_dataformat;
+
+	sensor_info->DelayFrame[SENSOR_SCENARIO_ID_NORMAL_PREVIEW] =
+		imgsensor_info.pre_delay_frame;
+	sensor_info->DelayFrame[SENSOR_SCENARIO_ID_NORMAL_CAPTURE] =
+		imgsensor_info.cap_delay_frame;
+	sensor_info->DelayFrame[SENSOR_SCENARIO_ID_NORMAL_VIDEO] =
+		imgsensor_info.video_delay_frame;
+	sensor_info->DelayFrame[SENSOR_SCENARIO_ID_HIGHSPEED_VIDEO] =
+		imgsensor_info.hs_video_delay_frame;
+	sensor_info->DelayFrame[SENSOR_SCENARIO_ID_SLIM_VIDEO] =
+		imgsensor_info.slim_video_delay_frame;
+
+	sensor_info->SensorMasterClockSwitch = 0; // not use
+	sensor_info->SensorDrivingCurrent = imgsensor_info.isp_driving_current;
+
+	// The frame of setting shutter default 0 for TG int
+	sensor_info->AEShutDelayFrame =
+		imgsensor_info.ae_shut_delay_frame;
+	// The frame of setting sensor gain
+	sensor_info->AESensorGainDelayFrame =
+		imgsensor_info.ae_sensor_gain_delay_frame;
+	sensor_info->AEISPGainDelayFrame =
+		imgsensor_info.ae_ispGain_delay_frame;
+	sensor_info->IHDR_Support = imgsensor_info.ihdr_support;
+	sensor_info->IHDR_LE_FirstLine = imgsensor_info.ihdr_le_firstline;
+	sensor_info->SensorModeNum = imgsensor_info.sensor_mode_num;
+
+	sensor_info->SensorMIPILaneNumber = imgsensor_info.mipi_lane_num;
+	sensor_info->SensorClockFreq = imgsensor_info.mclk;
+	sensor_info->SensorClockDividCount = 3; // not use
+	sensor_info->SensorClockRisingCount = 0;
+	sensor_info->SensorClockFallingCount = 2; // not use
+	sensor_info->SensorPixelClockCount = 3; // not use
+	sensor_info->SensorDataLatchCount = 2; // not use
+
+	sensor_info->SensorWidthSampling = 0;  // 0 is default 1x
+	sensor_info->SensorHightSampling = 0; // 0 is default 1x
+	sensor_info->SensorPacketECCOrder = 1;
+
+	return ERROR_NONE;
+}	//	get_info
+
+static int control(struct subdrv_ctx *ctx, enum MSDK_SCENARIO_ID_ENUM scenario_id,
+	MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+	MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+	LOG_DBG("scenario_id = %d\n", scenario_id);
+	ctx->current_scenario_id = scenario_id;
+	switch (scenario_id) {
+	case SENSOR_SCENARIO_ID_NORMAL_PREVIEW:
+		preview(ctx, image_window, sensor_config_data);
+		break;
+	case SENSOR_SCENARIO_ID_NORMAL_CAPTURE:
+		capture(ctx, image_window, sensor_config_data);
+		break;
+	case SENSOR_SCENARIO_ID_NORMAL_VIDEO:
+		normal_video(ctx, image_window, sensor_config_data);
+		break;
+	case SENSOR_SCENARIO_ID_HIGHSPEED_VIDEO:
+		hs_video(ctx, image_window, sensor_config_data);
+		break;
+	case SENSOR_SCENARIO_ID_SLIM_VIDEO:
+		slim_video(ctx, image_window, sensor_config_data);
+		break;
+	default:
+		LOG_WARN("Error ScenarioId setting (id = %d)\n", scenario_id);
+		preview(ctx, image_window, sensor_config_data);
+		return ERROR_INVALID_SCENARIO_ID;
+	}
+	return ERROR_NONE;
+} // control(ctx)
+
+static kal_uint32 set_video_mode(struct subdrv_ctx *ctx, UINT16 framerate)
+{
+	LOG_DBG("framerate = %u\n ", framerate);
+	// SetVideoMode Function should fix framerate
+	if (framerate == 0)
+		// Dynamic frame rate
+		return ERROR_NONE;
+	if ((framerate == 300) && (ctx->autoflicker_en == KAL_TRUE))
+		ctx->current_fps = 296;
+	else if ((framerate == 150) && (ctx->autoflicker_en == KAL_TRUE))
+		ctx->current_fps = 146;
+	else
+		ctx->current_fps = framerate;
+	set_max_framerate(ctx, ctx->current_fps, 1);
+
+	return ERROR_NONE;
+}
+
+static kal_uint32 set_auto_flicker_mode(struct subdrv_ctx *ctx, kal_bool enable, UINT16 framerate)
+{
+	LOG_DBG("enable = %d, framerate = %u\n", enable, framerate);
+	if (enable) //enable auto flicker
+		ctx->autoflicker_en = KAL_TRUE;
+	else //Cancel Auto flick
+		ctx->autoflicker_en = KAL_FALSE;
+	return ERROR_NONE;
+}
+
+static kal_uint32 set_max_framerate_by_scenario(struct subdrv_ctx *ctx,
+		enum MSDK_SCENARIO_ID_ENUM scenario_id, MUINT32 framerate)
+{
+	kal_uint32 frame_length;
+
+	LOG_DBG("scenario_id = %d, framerate = %u\n",
+		scenario_id, framerate);
+
+	switch (scenario_id) {
+	case SENSOR_SCENARIO_ID_NORMAL_PREVIEW:
+		frame_length =
+			imgsensor_info.pre.pclk /
+			framerate * 10 /
+			imgsensor_info.pre.linelength;
+		ctx->dummy_line =
+			(frame_length > imgsensor_info.pre.framelength) ?
+			(frame_length - imgsensor_info.pre.framelength) :
+			0;
+		ctx->frame_length =
+			imgsensor_info.pre.framelength + ctx->dummy_line;
+		ctx->min_frame_length = ctx->frame_length;
+		//set_dummy(ctx);
+		break;
+	case SENSOR_SCENARIO_ID_NORMAL_VIDEO:
+		if (framerate == 0)
+			return ERROR_NONE;
+		frame_length =
+			imgsensor_info.normal_video.pclk /
+			framerate * 10 /
+			imgsensor_info.normal_video.linelength;
+		ctx->dummy_line =
+			(frame_length > imgsensor_info.normal_video.framelength) ?
+			(frame_length - imgsensor_info.normal_video.framelength) :
+			0;
+		ctx->frame_length =
+			imgsensor_info.normal_video.framelength + ctx->dummy_line;
+		ctx->min_frame_length = ctx->frame_length;
+		//set_dummy(ctx);
+		break;
+	case SENSOR_SCENARIO_ID_NORMAL_CAPTURE:
+		if (ctx->current_fps ==
+				imgsensor_info.cap1.max_framerate) {
+			frame_length =
+				imgsensor_info.cap1.pclk /
+				framerate * 10 /
+				imgsensor_info.cap1.linelength;
+			ctx->dummy_line =
+				(frame_length > imgsensor_info.cap1.framelength) ?
+				(frame_length - imgsensor_info.cap1.framelength) :
+				0;
+			ctx->frame_length =
+				imgsensor_info.cap1.framelength + ctx->dummy_line;
+			ctx->min_frame_length = ctx->frame_length;
+		} else if (ctx->current_fps ==
+				imgsensor_info.cap2.max_framerate) {
+			frame_length =
+				imgsensor_info.cap2.pclk /
+				framerate * 10 /
+				imgsensor_info.cap2.linelength;
+			ctx->dummy_line =
+				(frame_length > imgsensor_info.cap2.framelength) ?
+				(frame_length - imgsensor_info.cap2.framelength) :
+				0;
+			ctx->frame_length =
+				imgsensor_info.cap2.framelength + ctx->dummy_line;
+			ctx->min_frame_length = ctx->frame_length;
+		} else {
+			if (ctx->current_fps !=
+				imgsensor_info.cap.max_framerate)
+				LOG_WARN(
+					"Warning: current_fps %u fps is not support,so use cap's setting: %u fps!\n",
+					framerate,
+					imgsensor_info.cap.max_framerate / 10);
+				frame_length =
+					imgsensor_info.cap.pclk /
+					framerate * 10 /
+					imgsensor_info.cap.linelength;
+				ctx->dummy_line =
+					(frame_length > imgsensor_info.cap.framelength) ?
+					(frame_length - imgsensor_info.cap.framelength) :
+					0;
+				ctx->frame_length =
+					imgsensor_info.cap.framelength + ctx->dummy_line;
+				ctx->min_frame_length = ctx->frame_length;
+		}
+		//set_dummy(ctx);
+		break;
+	case SENSOR_SCENARIO_ID_HIGHSPEED_VIDEO:
+		frame_length =
+			imgsensor_info.hs_video.pclk /
+			framerate * 10 /
+			imgsensor_info.hs_video.linelength;
+		ctx->dummy_line =
+			(frame_length > imgsensor_info.hs_video.framelength) ?
+			(frame_length - imgsensor_info.hs_video.framelength) :
+			0;
+		ctx->frame_length =
+			imgsensor_info.hs_video.framelength + ctx->dummy_line;
+		ctx->min_frame_length = ctx->frame_length;
+		//set_dummy(ctx);
+		break;
+	case SENSOR_SCENARIO_ID_SLIM_VIDEO:
+		frame_length =
+			imgsensor_info.slim_video.pclk /
+			framerate * 10 /
+			imgsensor_info.slim_video.linelength;
+		ctx->dummy_line =
+			(frame_length > imgsensor_info.slim_video.framelength) ?
+			(frame_length - imgsensor_info.slim_video.framelength) :
+			0;
+		ctx->frame_length =
+			imgsensor_info.slim_video.framelength + ctx->dummy_line;
+		ctx->min_frame_length = ctx->frame_length;
+		//set_dummy(ctx);
+		break;
+	default:  //coding with  preview scenario by default
+		frame_length =
+			imgsensor_info.pre.pclk /
+			framerate * 10 /
+			imgsensor_info.pre.linelength;
+		ctx->dummy_line =
+			(frame_length > imgsensor_info.pre.framelength) ?
+			(frame_length - imgsensor_info.pre.framelength) :
+			0;
+		ctx->frame_length =
+			imgsensor_info.pre.framelength + ctx->dummy_line;
+		ctx->min_frame_length = ctx->frame_length;
+		//set_dummy(ctx);
+		LOG_WARN("error scenario_id = %d, we use preview scenario\n",
+			scenario_id);
+		break;
+	}
+	return ERROR_NONE;
+}
+
+static kal_uint32 get_default_framerate_by_scenario(struct subdrv_ctx *ctx,
+		enum MSDK_SCENARIO_ID_ENUM scenario_id, MUINT32 *framerate)
+{
+	LOG_DBG("scenario_id = %d\n", scenario_id);
+
+	switch (scenario_id) {
+	case SENSOR_SCENARIO_ID_NORMAL_PREVIEW:
+		*framerate = imgsensor_info.pre.max_framerate;
+		break;
+	case SENSOR_SCENARIO_ID_NORMAL_VIDEO:
+		*framerate = imgsensor_info.normal_video.max_framerate;
+		break;
+	case SENSOR_SCENARIO_ID_NORMAL_CAPTURE:
+		*framerate = imgsensor_info.cap.max_framerate;
+		break;
+	case SENSOR_SCENARIO_ID_HIGHSPEED_VIDEO:
+		*framerate = imgsensor_info.hs_video.max_framerate;
+		break;
+	case SENSOR_SCENARIO_ID_SLIM_VIDEO:
+		*framerate = imgsensor_info.slim_video.max_framerate;
+		break;
+	default:
+		break;
+	}
+
+	return ERROR_NONE;
+}
+
+static kal_uint32 set_test_pattern_mode(struct subdrv_ctx *ctx, kal_bool enable)
+{
+	LOG_DBG("enable: %d\n", enable);
+
+	if (enable)
+		write_cmos_sensor_8(ctx, 0x503D, 0x80);
+	else
+		write_cmos_sensor_8(ctx, 0x503D, 0x00);
+
+	ctx->test_pattern = enable;
+	return ERROR_NONE;
+}
+
+static kal_uint32 streaming_control(struct subdrv_ctx *ctx, kal_bool enable)
+{
+	LOG_INFO("streaming_enable(0=Sw Standby,1=streaming): %d\n", enable);
+
+	if (enable)
+		write_cmos_sensor_8(ctx, 0x0100, 0x01);
+	else
+		write_cmos_sensor_8(ctx, 0x0100, 0x00);
+
+	mdelay(10);
+	return ERROR_NONE;
+}
+
+static int feature_control(struct subdrv_ctx *ctx, MSDK_SENSOR_FEATURE_ENUM feature_id,
+			UINT8 *feature_para, UINT32 *feature_para_len)
+{
+	UINT16 *feature_return_para_16 = (UINT16 *) feature_para;
+	UINT16 *feature_data_16 = (UINT16 *) feature_para;
+	UINT32 *feature_return_para_32 = (UINT32 *) feature_para;
+	UINT32 *feature_data_32 = (UINT32 *) feature_para;
+	unsigned long long *feature_data = (unsigned long long *) feature_para;
+	//unsigned long long *feature_return_para =
+	//(unsigned long long *) feature_para;
+	kal_uint32 rate;
+
+	struct SENSOR_WINSIZE_INFO_STRUCT *wininfo;
+	struct SENSOR_VC_INFO_STRUCT *pvcinfo;
+	//SET_SENSOR_AWB_GAIN *pSetSensorAWB =
+	//(SET_SENSOR_AWB_GAIN *)feature_para;
+	 MSDK_SENSOR_REG_INFO_STRUCT *sensor_reg_data =
+		 (MSDK_SENSOR_REG_INFO_STRUCT *) feature_para;
+
+	switch (feature_id) {
+	case SENSOR_FEATURE_GET_OUTPUT_FORMAT_BY_SCENARIO:
+		switch (*feature_data) {
+		case SENSOR_SCENARIO_ID_NORMAL_CAPTURE:
+		case SENSOR_SCENARIO_ID_NORMAL_VIDEO:
+		case SENSOR_SCENARIO_ID_HIGHSPEED_VIDEO:
+		case SENSOR_SCENARIO_ID_SLIM_VIDEO:
+		case SENSOR_SCENARIO_ID_NORMAL_PREVIEW:
+				*(feature_data + 1)
+				= (enum ACDK_SENSOR_OUTPUT_DATA_FORMAT_ENUM)
+					imgsensor_info.sensor_output_dataformat;
+			break;
+		}
+		break;
+	case SENSOR_FEATURE_GET_GAIN_RANGE_BY_SCENARIO:
+		*(feature_data + 1) = imgsensor_info.min_gain;
+		*(feature_data + 2) = imgsensor_info.max_gain;
+		break;
+	case SENSOR_FEATURE_GET_BASE_GAIN_ISO_AND_STEP:
+		*(feature_data + 0) = imgsensor_info.min_gain_iso;
+		*(feature_data + 1) = imgsensor_info.gain_step;
+		*(feature_data + 2) = imgsensor_info.gain_type;
+		break;
+	case SENSOR_FEATURE_GET_MIN_SHUTTER_BY_SCENARIO:
+		*(feature_data + 1) = imgsensor_info.min_shutter;
+		*(feature_data + 2) = imgsensor_info.exp_step;
+		break;
+	case SENSOR_FEATURE_GET_PERIOD:
+		*feature_return_para_16++ = ctx->line_length;
+		*feature_return_para_16 = ctx->frame_length;
+		*feature_para_len = 4;
+		break;
+	case SENSOR_FEATURE_GET_PIXEL_CLOCK_FREQ:
+		*feature_return_para_32 = ctx->pclk;
+		*feature_para_len = 4;
+		break;
+	case SENSOR_FEATURE_SET_ESHUTTER:
+		set_shutter(ctx, *feature_data);
+		break;
+	case SENSOR_FEATURE_SET_NIGHTMODE:
+		night_mode(ctx, (BOOL)*feature_data);
+		break;
+	case SENSOR_FEATURE_SET_GAIN:
+		set_gain(ctx, (UINT32)*feature_data);
+		break;
+	case SENSOR_FEATURE_SET_FLASHLIGHT:
+		break;
+	case SENSOR_FEATURE_SET_ISP_MASTER_CLOCK_FREQ:
+		break;
+	case SENSOR_FEATURE_SET_REGISTER:
+		write_cmos_sensor_8(ctx, sensor_reg_data->RegAddr, sensor_reg_data->RegData);
+		break;
+	case SENSOR_FEATURE_GET_REGISTER:
+		sensor_reg_data->RegData = read_cmos_sensor_8(ctx, sensor_reg_data->RegAddr);
+		break;
+	case SENSOR_FEATURE_GET_LENS_DRIVER_ID:
+		// get the lens driver ID from EEPROM or just
+		// return LENS_DRIVER_ID_DO_NOT_CARE
+		// if EEPROM does not exist in camera module.
+		*feature_return_para_32 = LENS_DRIVER_ID_DO_NOT_CARE;
+		*feature_para_len = 4;
+		break;
+	case SENSOR_FEATURE_SET_VIDEO_MODE:
+		set_video_mode(ctx, *feature_data);
+		break;
+	case SENSOR_FEATURE_CHECK_SENSOR_ID:
+		get_imgsensor_id(ctx, feature_return_para_32);
+		break;
+	case SENSOR_FEATURE_SET_AUTO_FLICKER_MODE:
+		set_auto_flicker_mode(ctx, (BOOL)*feature_data_16,
+			*(feature_data_16+1));
+		break;
+	case SENSOR_FEATURE_SET_MAX_FRAME_RATE_BY_SCENARIO:
+		set_max_framerate_by_scenario(ctx,
+			(enum MSDK_SCENARIO_ID_ENUM)*feature_data,
+			*(feature_data+1));
+		break;
+	case SENSOR_FEATURE_GET_DEFAULT_FRAME_RATE_BY_SCENARIO:
+		get_default_framerate_by_scenario(ctx,
+			(enum MSDK_SCENARIO_ID_ENUM)*(feature_data),
+			(MUINT32 *)(uintptr_t)(*(feature_data+1)));
+		break;
+	case SENSOR_FEATURE_SET_TEST_PATTERN:
+		set_test_pattern_mode(ctx, (BOOL)*feature_data);
+		break;
+	case SENSOR_FEATURE_GET_TEST_PATTERN_CHECKSUM_VALUE:
+		//for factory mode auto testing
+		*feature_return_para_32 = imgsensor_info.checksum_value;
+		*feature_para_len = 4;
+		break;
+	case SENSOR_FEATURE_SET_FRAMERATE:
+		LOG_DBG("current fps :%u\n", (UINT32)*feature_data);
+		ctx->current_fps = *feature_data;
+		break;
+	case SENSOR_FEATURE_SET_HDR:
+		LOG_DBG("ihdr enable :%u\n", (BOOL)*feature_data);
+		ctx->ihdr_mode = *feature_data;
+		break;
+	case SENSOR_FEATURE_GET_CROP_INFO:
+		LOG_DBG("SENSOR_FEATURE_GET_CROP_INFO scenarioId:%d\n",
+			(UINT32)*feature_data);
+		wininfo = (struct SENSOR_WINSIZE_INFO_STRUCT *)
+			(uintptr_t)(*(feature_data+1));
+
+		switch (*feature_data_32) {
+		case SENSOR_SCENARIO_ID_NORMAL_CAPTURE:
+			memcpy((void *)wininfo,
+				(void *)&imgsensor_winsize_info[1],
+				sizeof(struct SENSOR_WINSIZE_INFO_STRUCT));
+			break;
+		case SENSOR_SCENARIO_ID_NORMAL_VIDEO:
+			memcpy((void *)wininfo,
+				(void *)&imgsensor_winsize_info[2],
+				sizeof(struct SENSOR_WINSIZE_INFO_STRUCT));
+			break;
+		case SENSOR_SCENARIO_ID_HIGHSPEED_VIDEO:
+			memcpy((void *)wininfo,
+				(void *)&imgsensor_winsize_info[3],
+				sizeof(struct SENSOR_WINSIZE_INFO_STRUCT));
+			break;
+		case SENSOR_SCENARIO_ID_SLIM_VIDEO:
+			memcpy((void *)wininfo,
+				(void *)&imgsensor_winsize_info[4],
+				sizeof(struct SENSOR_WINSIZE_INFO_STRUCT));
+			break;
+		case SENSOR_SCENARIO_ID_NORMAL_PREVIEW:
+		default:
+			memcpy((void *)wininfo,
+				(void *)&imgsensor_winsize_info[0],
+				sizeof(struct SENSOR_WINSIZE_INFO_STRUCT));
+			break;
+		}
+		break;
+	case SENSOR_FEATURE_SET_IHDR_SHUTTER_GAIN:
+		LOG_DBG("SENSOR_SET_SENSOR_IHDR LE=%u, SE=%u, Gain=%u\n",
+			(UINT16)*feature_data,
+			(UINT16)*(feature_data+1),
+			(UINT16)*(feature_data+2));
+		ihdr_write_shutter_gain(ctx, (UINT16)*feature_data,
+			(UINT16)*(feature_data+1), (UINT16)*(feature_data+2));
+		break;
+	case SENSOR_FEATURE_GET_VC_INFO:
+		LOG_DBG("SENSOR_FEATURE_GET_VC_INFO 0x%x\n",
+			(UINT16)*feature_data);
+		pvcinfo = (struct SENSOR_VC_INFO_STRUCT *)
+			(uintptr_t)(*(feature_data+1));
+		switch (*feature_data_32) {
+		case SENSOR_SCENARIO_ID_NORMAL_CAPTURE:
+			memcpy((void *)pvcinfo,
+				(void *)&SENSOR_VC_INFO[1],
+				sizeof(struct SENSOR_VC_INFO_STRUCT));
+			break;
+		case SENSOR_SCENARIO_ID_NORMAL_VIDEO:
+			memcpy((void *)pvcinfo,
+				(void *)&SENSOR_VC_INFO[2],
+				sizeof(struct SENSOR_VC_INFO_STRUCT));
+			break;
+		case SENSOR_SCENARIO_ID_NORMAL_PREVIEW:
+		default:
+			memcpy((void *)pvcinfo,
+				(void *)&SENSOR_VC_INFO[0],
+				sizeof(struct SENSOR_VC_INFO_STRUCT));
+			break;
+		}
+		break;
+	case SENSOR_FEATURE_SET_HDR_SHUTTER:
+		LOG_DBG("SENSOR_FEATURE_SET_HDR_SHUTTER LE=%u, SE=%u\n",
+			(UINT16)*feature_data, (UINT16)*(feature_data+1));
+		ihdr_write_shutter(ctx, (UINT16)*feature_data,
+			(UINT16)*(feature_data+1));
+		break;
+	case SENSOR_FEATURE_GET_MIPI_PIXEL_RATE:
+		switch (*feature_data) {
+		case SENSOR_SCENARIO_ID_NORMAL_CAPTURE:
+			rate = imgsensor_info.cap.mipi_pixel_rate;
+			break;
+		case SENSOR_SCENARIO_ID_NORMAL_VIDEO:
+			rate = imgsensor_info.normal_video.mipi_pixel_rate;
+			break;
+		case SENSOR_SCENARIO_ID_HIGHSPEED_VIDEO:
+			rate = imgsensor_info.hs_video.mipi_pixel_rate;
+			break;
+		case SENSOR_SCENARIO_ID_SLIM_VIDEO:
+			rate = imgsensor_info.slim_video.mipi_pixel_rate;
+			break;
+		case SENSOR_SCENARIO_ID_NORMAL_PREVIEW:
+		default:
+			rate = imgsensor_info.pre.mipi_pixel_rate;
+			break;
+		}
+		*(MUINT32 *)(uintptr_t)(*(feature_data + 1)) = rate;
+		break;
+	case SENSOR_FEATURE_SET_STREAMING_SUSPEND:
+		LOG_DBG("SENSOR_FEATURE_SET_STREAMING_SUSPEND\n");
+		streaming_control(ctx, KAL_FALSE);
+		break;
+	case SENSOR_FEATURE_SET_STREAMING_RESUME:
+		LOG_DBG("SENSOR_FEATURE_SET_STREAMING_RESUME, shutter:%llu\n",
+			*feature_data);
+		if (*feature_data != 0)
+			set_shutter(ctx, *feature_data);
+		streaming_control(ctx, KAL_TRUE);
+		break;
+	case SENSOR_FEATURE_GET_PERIOD_BY_SCENARIO:
+		switch (*feature_data) {
+		case SENSOR_SCENARIO_ID_NORMAL_CAPTURE:
+			*(MUINT32 *)(uintptr_t)(*(feature_data + 1))
+			= (imgsensor_info.cap.framelength << 16)
+				+ imgsensor_info.cap.linelength;
+			break;
+		case SENSOR_SCENARIO_ID_NORMAL_VIDEO:
+			*(MUINT32 *)(uintptr_t)(*(feature_data + 1))
+			= (imgsensor_info.normal_video.framelength << 16)
+				+ imgsensor_info.normal_video.linelength;
+			break;
+		case SENSOR_SCENARIO_ID_HIGHSPEED_VIDEO:
+			*(MUINT32 *)(uintptr_t)(*(feature_data + 1))
+			= (imgsensor_info.hs_video.framelength << 16)
+				+ imgsensor_info.hs_video.linelength;
+			break;
+		case SENSOR_SCENARIO_ID_SLIM_VIDEO:
+			*(MUINT32 *)(uintptr_t)(*(feature_data + 1))
+			= (imgsensor_info.slim_video.framelength << 16)
+				+ imgsensor_info.slim_video.linelength;
+			break;
+		case SENSOR_SCENARIO_ID_NORMAL_PREVIEW:
+		default:
+			*(MUINT32 *)(uintptr_t)(*(feature_data + 1))
+			= (imgsensor_info.pre.framelength << 16)
+				+ imgsensor_info.pre.linelength;
+			break;
+		}
+		break;
+	case SENSOR_FEATURE_GET_PIXEL_CLOCK_FREQ_BY_SCENARIO:
+		switch (*feature_data) {
+		case SENSOR_SCENARIO_ID_NORMAL_CAPTURE:
+			*(MUINT32 *)(uintptr_t)(*(feature_data + 1))
+				= imgsensor_info.cap.pclk;
+			break;
+		case SENSOR_SCENARIO_ID_NORMAL_VIDEO:
+			*(MUINT32 *)(uintptr_t)(*(feature_data + 1))
+				= imgsensor_info.normal_video.pclk;
+			break;
+		case SENSOR_SCENARIO_ID_HIGHSPEED_VIDEO:
+			*(MUINT32 *)(uintptr_t)(*(feature_data + 1))
+				= imgsensor_info.hs_video.pclk;
+			break;
+		case SENSOR_SCENARIO_ID_SLIM_VIDEO:
+			*(MUINT32 *)(uintptr_t)(*(feature_data + 1))
+				= imgsensor_info.slim_video.pclk;
+			break;
+		case SENSOR_SCENARIO_ID_NORMAL_PREVIEW:
+		default:
+			*(MUINT32 *)(uintptr_t)(*(feature_data + 1))
+				= imgsensor_info.pre.pclk;
+			break;
+		}
+		break;
+	case SENSOR_FEATURE_GET_BINNING_TYPE:
+		switch (*(feature_data + 1)) {
+		case SENSOR_SCENARIO_ID_NORMAL_PREVIEW:
+		case SENSOR_SCENARIO_ID_HIGHSPEED_VIDEO:
+		case SENSOR_SCENARIO_ID_SLIM_VIDEO:
+		case SENSOR_SCENARIO_ID_NORMAL_CAPTURE:
+		case SENSOR_SCENARIO_ID_NORMAL_VIDEO:
+		default:
+			*feature_return_para_32 = 1; //BINNING_AVERAGE
+			break;
+		}
+		pr_debug("SENSOR_FEATURE_GET_BINNING_TYPE AE_binning_type:%d,\n",
+			*feature_return_para_32);
+		*feature_para_len = 4;
+
+		break;
+	default:
+		break;
+	}
+
+	return ERROR_NONE;
+} // feature_control(ctx)
+
+#ifdef IMGSENSOR_VC_ROUTING
+static struct mtk_mbus_frame_desc_entry frame_desc_prev[] = {
+	{
+		.bus.csi2 = {
+			.channel = 0,
+			.data_type = 0x2b,
+			.hsize = 0x0780,
+			.vsize = 0x0438,
+		},
+	},
+};
+
+static struct mtk_mbus_frame_desc_entry frame_desc_cap[] = {
+	{
+		.bus.csi2 = {
+			.channel = 0,
+			.data_type = 0x2b,
+			.hsize = 0x0780,
+			.vsize = 0x0438,
+		},
+	},
+};
+
+static int get_frame_desc(struct subdrv_ctx *ctx,
+		int scenario_id, struct mtk_mbus_frame_desc *fd)
+{
+	switch (scenario_id) {
+	case SENSOR_SCENARIO_ID_NORMAL_PREVIEW:
+		fd->type = MTK_MBUS_FRAME_DESC_TYPE_CSI2;
+		fd->num_entries = ARRAY_SIZE(frame_desc_prev);
+		memcpy(fd->entry, frame_desc_prev, sizeof(frame_desc_prev));
+		break;
+	case SENSOR_SCENARIO_ID_NORMAL_CAPTURE:
+	case SENSOR_SCENARIO_ID_NORMAL_VIDEO:
+		fd->type = MTK_MBUS_FRAME_DESC_TYPE_CSI2;
+		fd->num_entries = ARRAY_SIZE(frame_desc_cap);
+		memcpy(fd->entry, frame_desc_cap, sizeof(frame_desc_cap));
+		break;
+	default:
+		return -1;
+	}
+
+	return 0;
+}
+#endif
+static int vsync_notify(struct subdrv_ctx *ctx, unsigned int sof_cnt)
+{
+	kal_uint16 reg_gain;
+
+	reg_gain = ctx->gain;
+	if (reg_gain) {
+		//write_cmos_sensor_8(ctx, 0x350a, reg_gain >> 8);
+		//write_cmos_sensor_8(ctx, 0x350b, reg_gain & 0xFF);
+	}
+
+	LOG_DBG("sof_cnt %u reg_gain = 0x%x\n", sof_cnt, reg_gain);
+
+	return 0;
+};
+
+static const struct subdrv_ctx defctx = {
+	.ana_gain_def = MAX_GAIN,
+	.ana_gain_max = MAX_GAIN,
+	.ana_gain_min = MIN_GAIN,
+	.ana_gain_step = GAIN_STEP,
+	.exposure_def = 0x3D0,
+	.exposure_max = 0xffff - 10,
+	.exposure_min = 1,
+	.exposure_step = 1,
+	.max_frame_length = 0xffff,
+
+	.mirror = IMAGE_NORMAL,//mirrorflip information
+	//IMGSENSOR_MODE enum value,record current sensor mode,
+	//such as: INIT, Preview, Capture, Video,High Speed Video, Slim Video
+	.sensor_mode = IMGSENSOR_MODE_INIT,
+	.shutter = 0x3D0,//current shutter
+	.gain = BASEGAIN * 4,//current gain
+	.dummy_pixel = 0,//current dummypixel
+	.dummy_line = 0,  //current dummyline
+	//full size current fps : 24fps for PIP, 30fps for Normal or ZSD
+	.current_fps = 300,
+	//auto flicker enable: KAL_FALSE for disable auto flicker,
+	//KAL_TRUE for enable auto flicker
+	.autoflicker_en = KAL_FALSE,
+	//test pattern mode or not. KAL_FALSE for in test pattern mode,
+	//KAL_TRUE for normal output
+	.test_pattern = KAL_FALSE,
+	//current scenario id
+	.current_scenario_id = SENSOR_SCENARIO_ID_NORMAL_PREVIEW,
+	.ihdr_mode = 0, //sensor need support LE, SE with HDR feature
+	.i2c_write_id = 0x6c,
+};
+
+static int init_ctx(struct subdrv_ctx *ctx,
+		struct i2c_client *i2c_client, u8 i2c_write_id)
+{
+	memcpy(ctx, &defctx, sizeof(*ctx));
+	ctx->i2c_client = i2c_client;
+	ctx->i2c_write_id = i2c_write_id;
+	return 0;
+}
+
+static struct subdrv_ops ops = {
+	.get_id = get_imgsensor_id,
+	.init_ctx = init_ctx,
+	.open = open,
+	.get_info = get_info,
+	.get_resolution = get_resolution,
+	.control = control,
+	.feature_control = feature_control,
+	.close = close,
+#ifdef IMGSENSOR_VC_ROUTING
+	.get_frame_desc = get_frame_desc,
+#endif
+	.vsync_notify = vsync_notify,
+};
+
+static struct subdrv_pw_seq_entry pw_seq[] = {
+	{HW_ID_MCLK, 24, 0},
+	{HW_ID_MCLK_DRIVING_CURRENT, 2, 1},
+	{HW_ID_DOVDD, 1800000, 0},
+	{HW_ID_AVDD, 2800000, 0},
+	{HW_ID_DVDD, 1000000, 0},
+	{HW_ID_RST, 0, 10},
+	{HW_ID_RST, 1, 10},
+	{HW_ID_PDN, 0, 10},
+	{HW_ID_PDN, 1, 10},
+};
+
+const struct subdrv_entry ov5648_mipi_raw_entry = {
+	.name = "ov5648_mipi_raw",
+	.id = OV5648MIPI_SENSOR_ID,
+	.pw_seq = pw_seq,
+	.pw_seq_cnt = ARRAY_SIZE(pw_seq),
+	.ops = &ops,
+};
+
diff --git a/drivers/misc/mediatek/imgsensor/src-v4l2/common/ov5648_mipi_raw/ov5648mipiraw_Sensor.h b/drivers/misc/mediatek/imgsensor/src-v4l2/common/ov5648_mipi_raw/ov5648mipiraw_Sensor.h
new file mode 100644
index 0000000..4ec58e7
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src-v4l2/common/ov5648_mipi_raw/ov5648mipiraw_Sensor.h
@@ -0,0 +1,164 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2019 MediaTek Inc.
+ */
+
+/*****************************************************************************
+ *
+ * Filename:
+ * ---------
+ *  ov5648mipi_Sensor.h
+ *
+ * Project:
+ * --------
+ *  ALPS
+ *
+ * Description:
+ * ------------
+ *  CMOS sensor header file
+ *
+ ****************************************************************************/
+#ifndef _OV5648MIPI_SENSOR_H
+#define _OV5648MIPI_SENSOR_H
+
+enum{
+	IMGSENSOR_MODE_INIT,
+	IMGSENSOR_MODE_PREVIEW,
+	IMGSENSOR_MODE_CAPTURE,
+	IMGSENSOR_MODE_VIDEO,
+	IMGSENSOR_MODE_HIGH_SPEED_VIDEO,
+	IMGSENSOR_MODE_SLIM_VIDEO,
+	IMGSENSOR_MODE_CUSTOM1,
+	IMGSENSOR_MODE_CUSTOM2,
+};
+
+struct imgsensor_mode_struct {
+	kal_uint32 pclk;//record different mode's pclk
+	kal_uint32 linelength;//record different mode's linelength
+	kal_uint32 framelength;//record different mode's framelength
+
+	kal_uint8 startx;//record different mode's startx of grabwindow
+	kal_uint8 starty;//record different mode's startx of grabwindow
+
+	//record different mode's width of grabwindow
+	kal_uint16 grabwindow_width;
+	//record different mode's height of grabwindow
+	kal_uint16 grabwindow_height;
+
+	/*  following for
+	 *  MIPIDataLowPwr2HighSpeedSettleDelayCount
+	 *  by different scenario
+	 */
+	kal_uint8 mipi_data_lp2hs_settle_dc;
+	kal_uint32  mipi_pixel_rate;
+
+	//  following for GetDefaultFramerateByScenario()
+	kal_uint16 max_framerate;
+};
+
+// SENSOR PRIVATE STRUCT FOR VARIABLES
+struct imgsensor_struct {
+	kal_uint8 mirror;//mirrorflip information
+
+	kal_uint8 sensor_mode;//record IMGSENSOR_MODE enum value
+
+	kal_uint32 shutter;//current shutter
+	kal_uint32 gain;//current gain
+
+	kal_uint32 pclk;//current pclk
+
+	kal_uint32 frame_length;//current framelength
+	kal_uint32 line_length;//current linelength
+
+	kal_uint32 min_frame_length;//current min  framelength to max framerate
+	kal_uint16 dummy_pixel;//current dummypixel
+	kal_uint16 dummy_line;//current dummline
+
+	kal_uint16 current_fps;//current max fps
+	kal_bool   autoflicker_en;//record autoflicker enable or disable
+	kal_bool test_pattern;//record test pattern mode or not
+	enum MSDK_SCENARIO_ID_ENUM current_scenario_id;//current scenario id
+	kal_uint8  ihdr_mode;//ihdr mode 0: disable, 1: ihdr, 2:mVHDR, 9:zigzag
+
+	kal_uint8 i2c_write_id;//record current sensor's i2c write id
+};
+
+// SENSOR PRIVATE STRUCT FOR CONSTANT
+struct imgsensor_info_struct {
+	kal_uint32 sensor_id;//record sensor id defined in Kd_imgsensor.h
+	kal_uint32 checksum_value;//checksum value for Camera Auto Test
+	//preview scenario relative information
+	struct imgsensor_mode_struct pre;
+	//capture scenario relative information
+	struct imgsensor_mode_struct cap;
+	//capture for PIP 24fps relative information
+	struct imgsensor_mode_struct cap1;
+	//capture for PIP 24fps relative information
+	struct imgsensor_mode_struct cap2;
+	//normal video  scenario relative information
+	struct imgsensor_mode_struct normal_video;
+	//high speed video scenario relative information
+	struct imgsensor_mode_struct hs_video;
+	//slim video for VT scenario relative information
+	struct imgsensor_mode_struct slim_video;
+	struct imgsensor_mode_struct custom1;
+	struct imgsensor_mode_struct custom2;
+
+	kal_uint8  ae_shut_delay_frame;//shutter delay frame for AE cycle
+	//sensor gain delay frame for AE cycle
+	kal_uint8  ae_sensor_gain_delay_frame;
+	//isp gain delay frame for AE cycle
+	kal_uint8  ae_ispGain_delay_frame;
+	// The delay frame of setting frame length
+	kal_uint8 frame_time_delay_frame;
+	kal_uint8  ihdr_support;//1, support; 0,not support
+	kal_uint8  ihdr_le_firstline;//1,le first ; 0, se first
+	kal_uint8  sensor_mode_num;//support sensor mode num
+
+	kal_uint8  cap_delay_frame;//enter capture delay frame num
+	kal_uint8  pre_delay_frame;//enter preview delay frame num
+	kal_uint8  video_delay_frame;//enter video delay frame num
+	//enter high speed video  delay frame num
+	kal_uint8  hs_video_delay_frame;
+	kal_uint8  slim_video_delay_frame;//enter slim video delay frame num
+	kal_uint8 custom1_delay_frame;// enter custom1 delay frame num
+	kal_uint8 custom2_delay_frame;// enter custom1 delay frame num
+	kal_uint8  margin;//sensor framelength & shutter margin
+	kal_uint32 min_shutter;//min shutter
+	//max framelength by sensor register's limitation
+	kal_uint32 max_frame_length;
+	kal_uint32 min_gain;
+	kal_uint32 max_gain;
+	kal_uint32 min_gain_iso;
+	kal_uint32 gain_step;
+	kal_uint32 exp_step;
+	kal_uint32 gain_type;
+
+	kal_uint8  isp_driving_current;//mclk driving current
+	kal_uint8  sensor_interface_type;//sensor_interface_type
+	//0,MIPI_OPHY_NCSI2; 1,MIPI_OPHY_CSI2,
+	//default is NCSI2, don't modify this para
+	kal_uint8  mipi_sensor_type;
+	//0, high speed signal auto detect; 1, use settle delay,unit is ns,
+	//default is auto detect, don't modify this para
+	kal_uint8  mipi_settle_delay_mode;
+	kal_uint8  sensor_output_dataformat;
+	kal_uint8  mclk;//mclk value, suggest 24 or 26 for 24Mhz or 26Mhz
+
+	kal_uint8  mipi_lane_num;//mipi lane num
+	//record sensor support all write id addr,
+	//only supprt 4must end with 0xff
+	kal_uint8  i2c_addr_table[5];
+};
+
+// SENSOR READ/WRITE ID
+//#define IMGSENSOR_WRITE_ID_1 (0x6c)
+//#define IMGSENSOR_READ_ID_1  (0x6d)
+//#define IMGSENSOR_WRITE_ID_2 (0x20)
+//#define IMGSENSOR_READ_ID_2  (0x21)
+
+extern int iReadRegI2C(u8 *a_pSendData, u16 a_sizeSendData,
+		u8 *a_pRecvData, u16 a_sizeRecvData, u16 i2cId);
+extern int iWriteRegI2C(u8 *a_pSendData, u16 a_sizeSendData, u16 i2cId);
+
+#endif
diff --git a/drivers/misc/mediatek/imgsensor/src-v4l2/common/ov5648_mipi_raw/subdrv.mk b/drivers/misc/mediatek/imgsensor/src-v4l2/common/ov5648_mipi_raw/subdrv.mk
new file mode 100644
index 0000000..caea679
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src-v4l2/common/ov5648_mipi_raw/subdrv.mk
@@ -0,0 +1,9 @@
+# SPDX-License-Identifier: GPL-2.0
+# Copyright (C) 2020 MediaTek Inc.
+
+ccflags-y += \
+        -Wno-error=unused-variable \
+        -Wno-error=unused-function
+
+imgsensor-objs += \
+	$(subdrv-rpath)/ov5648mipiraw_Sensor.o
-- 
2.17.1

